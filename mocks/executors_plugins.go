// Code generated by MockGen. DO NOT EDIT.
// Source: internal/build/executors_plugins.go
//
// Generated by this command:
//
//	mockgen -source=internal/build/executors_plugins.go -destination=mocks/executors_plugins.go --package=mocks --exclude_interfaces=step
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	build "go.stplr.dev/stplr/internal/build"
	manager "go.stplr.dev/stplr/internal/manager"
	distro "go.stplr.dev/stplr/pkg/distro"
	staplerfile "go.stplr.dev/stplr/pkg/staplerfile"
	types "go.stplr.dev/stplr/pkg/types"
	gomock "go.uber.org/mock/gomock"
)

// MockInstallerExecutor is a mock of InstallerExecutor interface.
type MockInstallerExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockInstallerExecutorMockRecorder
	isgomock struct{}
}

// MockInstallerExecutorMockRecorder is the mock recorder for MockInstallerExecutor.
type MockInstallerExecutorMockRecorder struct {
	mock *MockInstallerExecutor
}

// NewMockInstallerExecutor creates a new mock instance.
func NewMockInstallerExecutor(ctrl *gomock.Controller) *MockInstallerExecutor {
	mock := &MockInstallerExecutor{ctrl: ctrl}
	mock.recorder = &MockInstallerExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstallerExecutor) EXPECT() *MockInstallerExecutorMockRecorder {
	return m.recorder
}

// Install mocks base method.
func (m *MockInstallerExecutor) Install(ctx context.Context, pkgs []string, opts *manager.Opts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Install", ctx, pkgs, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Install indicates an expected call of Install.
func (mr *MockInstallerExecutorMockRecorder) Install(ctx, pkgs, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Install", reflect.TypeOf((*MockInstallerExecutor)(nil).Install), ctx, pkgs, opts)
}

// InstallLocal mocks base method.
func (m *MockInstallerExecutor) InstallLocal(ctx context.Context, paths []string, opts *manager.Opts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstallLocal", ctx, paths, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// InstallLocal indicates an expected call of InstallLocal.
func (mr *MockInstallerExecutorMockRecorder) InstallLocal(ctx, paths, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstallLocal", reflect.TypeOf((*MockInstallerExecutor)(nil).InstallLocal), ctx, paths, opts)
}

// Remove mocks base method.
func (m *MockInstallerExecutor) Remove(ctx context.Context, pkgs []string, opts *manager.Opts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx, pkgs, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockInstallerExecutorMockRecorder) Remove(ctx, pkgs, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockInstallerExecutor)(nil).Remove), ctx, pkgs, opts)
}

// RemoveAlreadyInstalled mocks base method.
func (m *MockInstallerExecutor) RemoveAlreadyInstalled(ctx context.Context, pkgs []string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAlreadyInstalled", ctx, pkgs)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveAlreadyInstalled indicates an expected call of RemoveAlreadyInstalled.
func (mr *MockInstallerExecutorMockRecorder) RemoveAlreadyInstalled(ctx, pkgs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAlreadyInstalled", reflect.TypeOf((*MockInstallerExecutor)(nil).RemoveAlreadyInstalled), ctx, pkgs)
}

// MockScriptCopier is a mock of ScriptCopier interface.
type MockScriptCopier struct {
	ctrl     *gomock.Controller
	recorder *MockScriptCopierMockRecorder
	isgomock struct{}
}

// MockScriptCopierMockRecorder is the mock recorder for MockScriptCopier.
type MockScriptCopierMockRecorder struct {
	mock *MockScriptCopier
}

// NewMockScriptCopier creates a new mock instance.
func NewMockScriptCopier(ctrl *gomock.Controller) *MockScriptCopier {
	mock := &MockScriptCopier{ctrl: ctrl}
	mock.recorder = &MockScriptCopierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScriptCopier) EXPECT() *MockScriptCopierMockRecorder {
	return m.recorder
}

// Copy mocks base method.
func (m *MockScriptCopier) Copy(ctx context.Context, f *staplerfile.ScriptFile, info *distro.OSRelease) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", ctx, f, info)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Copy indicates an expected call of Copy.
func (mr *MockScriptCopierMockRecorder) Copy(ctx, f, info any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockScriptCopier)(nil).Copy), ctx, f, info)
}

// CopyOut mocks base method.
func (m *MockScriptCopier) CopyOut(ctx context.Context, from, dest string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyOut", ctx, from, dest, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyOut indicates an expected call of CopyOut.
func (mr *MockScriptCopierMockRecorder) CopyOut(ctx, from, dest, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyOut", reflect.TypeOf((*MockScriptCopier)(nil).CopyOut), ctx, from, dest, uid, gid)
}

// MockScriptExecutor is a mock of ScriptExecutor interface.
type MockScriptExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockScriptExecutorMockRecorder
	isgomock struct{}
}

// MockScriptExecutorMockRecorder is the mock recorder for MockScriptExecutor.
type MockScriptExecutorMockRecorder struct {
	mock *MockScriptExecutor
}

// NewMockScriptExecutor creates a new mock instance.
func NewMockScriptExecutor(ctrl *gomock.Controller) *MockScriptExecutor {
	mock := &MockScriptExecutor{ctrl: ctrl}
	mock.recorder = &MockScriptExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScriptExecutor) EXPECT() *MockScriptExecutorMockRecorder {
	return m.recorder
}

// ExecuteSecondPass mocks base method.
func (m *MockScriptExecutor) ExecuteSecondPass(ctx context.Context, input *build.BuildInput, sf *staplerfile.ScriptFile, varsOfPackages []*staplerfile.Package, repoDeps []string, builtDeps []*build.BuiltDep, basePkg string) ([]*build.BuiltDep, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteSecondPass", ctx, input, sf, varsOfPackages, repoDeps, builtDeps, basePkg)
	ret0, _ := ret[0].([]*build.BuiltDep)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteSecondPass indicates an expected call of ExecuteSecondPass.
func (mr *MockScriptExecutorMockRecorder) ExecuteSecondPass(ctx, input, sf, varsOfPackages, repoDeps, builtDeps, basePkg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteSecondPass", reflect.TypeOf((*MockScriptExecutor)(nil).ExecuteSecondPass), ctx, input, sf, varsOfPackages, repoDeps, builtDeps, basePkg)
}

// ParsePackages mocks base method.
func (m *MockScriptExecutor) ParsePackages(ctx context.Context, file *staplerfile.ScriptFile, packages []string, info distro.OSRelease) (string, []*staplerfile.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParsePackages", ctx, file, packages, info)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].([]*staplerfile.Package)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ParsePackages indicates an expected call of ParsePackages.
func (mr *MockScriptExecutorMockRecorder) ParsePackages(ctx, file, packages, info any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParsePackages", reflect.TypeOf((*MockScriptExecutor)(nil).ParsePackages), ctx, file, packages, info)
}

// PrepareDirs mocks base method.
func (m *MockScriptExecutor) PrepareDirs(ctx context.Context, input *build.BuildInput, basePkg string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareDirs", ctx, input, basePkg)
	ret0, _ := ret[0].(error)
	return ret0
}

// PrepareDirs indicates an expected call of PrepareDirs.
func (mr *MockScriptExecutorMockRecorder) PrepareDirs(ctx, input, basePkg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareDirs", reflect.TypeOf((*MockScriptExecutor)(nil).PrepareDirs), ctx, input, basePkg)
}

// Read mocks base method.
func (m *MockScriptExecutor) Read(ctx context.Context, scriptPath string) (*staplerfile.ScriptFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", ctx, scriptPath)
	ret0, _ := ret[0].(*staplerfile.ScriptFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockScriptExecutorMockRecorder) Read(ctx, scriptPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockScriptExecutor)(nil).Read), ctx, scriptPath)
}

// MockReposExecutor is a mock of ReposExecutor interface.
type MockReposExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockReposExecutorMockRecorder
	isgomock struct{}
}

// MockReposExecutorMockRecorder is the mock recorder for MockReposExecutor.
type MockReposExecutorMockRecorder struct {
	mock *MockReposExecutor
}

// NewMockReposExecutor creates a new mock instance.
func NewMockReposExecutor(ctrl *gomock.Controller) *MockReposExecutor {
	mock := &MockReposExecutor{ctrl: ctrl}
	mock.recorder = &MockReposExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReposExecutor) EXPECT() *MockReposExecutorMockRecorder {
	return m.recorder
}

// PullOneAndUpdateFromConfig mocks base method.
func (m *MockReposExecutor) PullOneAndUpdateFromConfig(ctx context.Context, repo *types.Repo) (types.Repo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PullOneAndUpdateFromConfig", ctx, repo)
	ret0, _ := ret[0].(types.Repo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PullOneAndUpdateFromConfig indicates an expected call of PullOneAndUpdateFromConfig.
func (mr *MockReposExecutorMockRecorder) PullOneAndUpdateFromConfig(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullOneAndUpdateFromConfig", reflect.TypeOf((*MockReposExecutor)(nil).PullOneAndUpdateFromConfig), ctx, repo)
}

// MockScriptReader is a mock of ScriptReader interface.
type MockScriptReader struct {
	ctrl     *gomock.Controller
	recorder *MockScriptReaderMockRecorder
	isgomock struct{}
}

// MockScriptReaderMockRecorder is the mock recorder for MockScriptReader.
type MockScriptReaderMockRecorder struct {
	mock *MockScriptReader
}

// NewMockScriptReader creates a new mock instance.
func NewMockScriptReader(ctrl *gomock.Controller) *MockScriptReader {
	mock := &MockScriptReader{ctrl: ctrl}
	mock.recorder = &MockScriptReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScriptReader) EXPECT() *MockScriptReaderMockRecorder {
	return m.recorder
}

// Read mocks base method.
func (m *MockScriptReader) Read(ctx context.Context, path string) (*staplerfile.ScriptFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", ctx, path)
	ret0, _ := ret[0].(*staplerfile.ScriptFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockScriptReaderMockRecorder) Read(ctx, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockScriptReader)(nil).Read), ctx, path)
}

// MockPackagesParser is a mock of PackagesParser interface.
type MockPackagesParser struct {
	ctrl     *gomock.Controller
	recorder *MockPackagesParserMockRecorder
	isgomock struct{}
}

// MockPackagesParserMockRecorder is the mock recorder for MockPackagesParser.
type MockPackagesParserMockRecorder struct {
	mock *MockPackagesParser
}

// NewMockPackagesParser creates a new mock instance.
func NewMockPackagesParser(ctrl *gomock.Controller) *MockPackagesParser {
	mock := &MockPackagesParser{ctrl: ctrl}
	mock.recorder = &MockPackagesParserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackagesParser) EXPECT() *MockPackagesParserMockRecorder {
	return m.recorder
}

// ParsePackages mocks base method.
func (m *MockPackagesParser) ParsePackages(ctx context.Context, file *staplerfile.ScriptFile, packages []string, info distro.OSRelease) (string, []*staplerfile.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParsePackages", ctx, file, packages, info)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].([]*staplerfile.Package)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ParsePackages indicates an expected call of ParsePackages.
func (mr *MockPackagesParserMockRecorder) ParsePackages(ctx, file, packages, info any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParsePackages", reflect.TypeOf((*MockPackagesParser)(nil).ParsePackages), ctx, file, packages, info)
}
